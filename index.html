<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>HarriPath Visualizer</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --grid-line: #3e3e42;
            --highlight: #4caf50;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Área do Campo (Esquerda) */
        #canvas-container {
            flex: 1;
            display: flex;
            justify_content: center;
            align-items: center;
            position: relative;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            background-color: #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            background-size: cover;
            /* Imagem de fundo da temporada atual (Into the Deep) ou genérica */
            background-image: url('https://upload.wikimedia.org/wikipedia/commons/5/5c/Grey_square.jpg'); 
        }

        /* Painel de Controle (Direita) */
        #sidebar {
            width: 350px;
            background-color: var(--panel-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #000;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
        }

        h1 { margin-top: 0; font-size: 1.5rem; color: var(--accent-color); }
        h3 { border-bottom: 1px solid #555; padding-bottom: 5px; margin-top: 20px; }

        .control-group {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="number"] {
            width: 60px;
            padding: 5px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }

        button {
            padding: 10px 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover { background-color: #005f9e; }
        button.secondary { background-color: #555; }
        button.danger { background-color: #d32f2f; }

        textarea {
            width: 100%;
            height: 150px;
            background-color: #1e1e1e;
            color: #9cdcfe; /* Cor de código Java */
            border: 1px solid #444;
            padding: 10px;
            font-family: 'Consolas', 'Courier New', monospace;
            resize: vertical;
            margin-bottom: 10px;
        }

        .stats {
            font-size: 0.9rem;
            color: #aaa;
            margin-top: auto;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="fieldCanvas" width="600" height="600"></canvas>
    </div>

    <div id="sidebar">
        <h1>HarriPath Planner</h1>

        <div class="control-group">
            <label>Grade (N x N):</label>
            <input type="number" id="gridSize" value="10" min="2" max="20">
            <button class="secondary" onclick="resetGrid()">Atualizar</button>
        </div>

        <div class="control-group">
            <button class="secondary" onclick="undoLast()">Desfazer Último</button>
            <button class="danger" onclick="clearPath()">Limpar Tudo</button>
        </div>

        <h3>Código Java Gerado</h3>
        <p style="font-size: 0.8rem; color:#888;">Cole isso dentro do seu <code>runOpMode()</code>:</p>
        <textarea id="outputCode" readonly></textarea>
        <button onclick="copyToClipboard()">Copiar Código</button>

        <div class="stats">
            <p>Posição Mouse: <span id="mousePos">-</span></p>
            <p>ID Quadrado: <span id="tileId">-</span></p>
        </div>
    </div>

    <script>
        // ================= CONFIGURAÇÕES =================
        const FIELD_SIZE_INCHES = 144; // Tamanho real FTC
        const CANVAS_SIZE = 600;       // Tamanho na tela (pixels)
        
        let GRID_ROWS = 10;
        let GRID_COLS = 10;
        
        // Estado
        let path = []; // Lista de IDs
        
        // Elementos
        const canvas = document.getElementById('fieldCanvas');
        const ctx = canvas.getContext('2d');
        const output = document.getElementById('outputCode');
        const mouseInfo = document.getElementById('mousePos');
        const tileInfo = document.getElementById('tileId');

        // ================= LÓGICA CORE (Igual ao Java) =================
        
        // Inicialização
        function init() {
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            
            // Event Listeners
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('click', onMouseClick);
            
            draw();
            updateCode();
        }

        // Função principal de desenho
        function draw() {
            // 1. Limpar
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // 2. Desenhar Grade
            const tileW = CANVAS_SIZE / GRID_COLS;
            const tileH = CANVAS_SIZE / GRID_ROWS;

            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '10px Arial';

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    let x = c * tileW;
                    let y = r * tileH;

                    // Desenhar quadrado
                    ctx.strokeRect(x, y, tileW, tileH);

                    // Calcular ID (Lógica HarriGrid.java: começa embaixo)
                    // No Canvas, y=0 é o topo. No Java HarriGrid, row 0 é o fundo.
                    // Temos que inverter a linha para calcular o ID visualmente correto.
                    let javaRow = (GRID_ROWS - 1) - r;
                    let id = (javaRow * GRID_COLS) + c + 1;

                    // Desenhar número do ID bem clarinho
                    ctx.fillStyle = '#555';
                    ctx.fillText(id, x + tileW/2, y + tileH/2);
                }
            }

            // 3. Desenhar Eixos (Centro da Arena)
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(CANVAS_SIZE/2, 0); ctx.lineTo(CANVAS_SIZE/2, CANVAS_SIZE); // Y
            ctx.moveTo(0, CANVAS_SIZE/2); ctx.lineTo(CANVAS_SIZE, CANVAS_SIZE/2); // X
            ctx.stroke();

            // 4. Desenhar Caminho
            if (path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';

                for (let i = 0; i < path.length; i++) {
                    let center = getCanvasCenterFromID(path[i]);
                    if (i === 0) ctx.moveTo(center.x, center.y);
                    else ctx.lineTo(center.x, center.y);
                    
                    // Desenhar ponto
                    drawCircle(center.x, center.y, 4, '#fff');
                }
                ctx.stroke();
            }
        }

        // ================= MATEMÁTICA =================

        // Converte ID (1..100) para coordenadas do Canvas (pixels)
        function getCanvasCenterFromID(id) {
            let adjustedId = id - 1;
            let javaRow = Math.floor(adjustedId / GRID_COLS);
            let col = adjustedId % GRID_COLS;

            // Inverter linha para canvas
            let canvasRow = (GRID_ROWS - 1) - javaRow;

            let tileW = CANVAS_SIZE / GRID_COLS;
            let tileH = CANVAS_SIZE / GRID_ROWS;

            return {
                x: (col * tileW) + (tileW / 2),
                y: (canvasRow * tileH) + (tileH / 2)
            };
        }

        // Converte Mouse (pixels) para ID e Coordenadas Reais (polegadas)
        function getInfoFromMouse(mx, my) {
            let tileW = CANVAS_SIZE / GRID_COLS;
            let tileH = CANVAS_SIZE / GRID_ROWS;

            let col = Math.floor(mx / tileW);
            let canvasRow = Math.floor(my / tileH);

            // Proteção contra sair da borda
            if(col >= GRID_COLS) col = GRID_COLS - 1;
            if(canvasRow >= GRID_ROWS) canvasRow = GRID_ROWS - 1;

            // Converter para Java Row
            let javaRow = (GRID_ROWS - 1) - canvasRow;
            let id = (javaRow * GRID_COLS) + col + 1;

            // Calcular X/Y em polegadas (Centro 0,0)
            // X = (mx / total) * 144 - 72
            let realX = (mx / CANVAS_SIZE) * FIELD_SIZE_INCHES - (FIELD_SIZE_INCHES/2);
            // Y no Java cresce pra cima, no mouse cresce pra baixo. Inverter.
            let realY = -((my / CANVAS_SIZE) * FIELD_SIZE_INCHES - (FIELD_SIZE_INCHES/2));

            return { id, realX, realY };
        }

        // ================= INTERAÇÃO =================

        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const info = getInfoFromMouse(mx, my);
            
            mouseInfo.textContent = `X: ${info.realX.toFixed(1)}, Y: ${info.realY.toFixed(1)}`;
            tileInfo.textContent = info.id;
        }

        function onMouseClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const info = getInfoFromMouse(mx, my);
            
            // Adicionar ao caminho
            path.push(info.id);
            
            draw();
            updateCode();
        }

        // ================= CONTROLES UI =================

        function updateCode() {
            if (path.length === 0) {
                output.value = "// Clique na grade para gerar o caminho...";
                return;
            }

            let code = `// Inicializa\n`;
            code += `HarriGrid grid = new HarriGrid(144, ${GRID_ROWS});\n`;
            code += `HarriPath path = new HarriPath(grid);\n\n`;
            code += `// Caminho Gerado\npath`;
            
            path.forEach(id => {
                code += `.add(${id})`;
            });
            code += `;`;

            output.value = code;
        }

        function undoLast() {
            path.pop();
            draw();
            updateCode();
        }

        function clearPath() {
            path = [];
            draw();
            updateCode();
        }

        function resetGrid() {
            let val = document.getElementById('gridSize').value;
            GRID_ROWS = parseInt(val);
            GRID_COLS = parseInt(val);
            path = [];
            draw();
            updateCode();
        }
        
        function copyToClipboard() {
            output.select();
            document.execCommand('copy');
            alert("Código copiado!");
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();

    </script>
</body>
</html>
