<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>HarriPath V2 - Start Position</title>
    <style>
        :root { --bg: #1e1e1e; --panel: #252526; --text: #d4d4d4; --accent: #007acc; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); display: flex; height: 100vh; margin: 0; overflow: hidden; }
        #canvas-container { flex: 1; display: flex; justify-content: center; align-items: center; background: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px; }
        canvas { background: #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: crosshair; }
        #sidebar { width: 320px; background: var(--panel); padding: 20px; display: flex; flex-direction: column; border-left: 1px solid #000; }
        textarea { width: 100%; height: 200px; background: #1e1e1e; color: #9cdcfe; border: 1px solid #444; font-family: monospace; margin-top: 10px; }
        button { padding: 10px; margin-top: 5px; background: var(--accent); color: white; border: none; cursor: pointer; }
        button.red { background: #d32f2f; }
        .info { font-size: 0.8rem; color: #aaa; margin-top: 10px; }
        .instructions { background: #333; padding: 10px; font-size: 0.8rem; border-left: 3px solid #ebce00; margin-bottom: 10px;}
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="fieldCanvas" width="600" height="600"></canvas>
    </div>
    <div id="sidebar">
        <h2 style="color:var(--accent)">HarriPath V2</h2>
        <div class="instructions">
            <b>Botão Esquerdo:</b> Adiciona destino (Waypoint)<br>
            <b>Botão Direito:</b> Define onde o robô NASCE (Start)<br>
            <b>Ctrl + Z:</b> Desfazer
        </div>
        
        <label>Código Gerado:</label>
        <textarea id="outputCode" readonly></textarea>
        <button onclick="copyCode()">Copiar Código</button>
        <button class="red" onclick="clearPath()">Limpar Tudo</button>

        <div class="info">
            <p>Mouse: <span id="mousePos">-</span></p>
            <p>Status: <span id="statusTxt">Aguardando...</span></p>
        </div>
    </div>

    <script>
        const FIELD_SIZE = 144; 
        const CANVAS_SIZE = 600;
        const GRID = 10;
        
        let path = [];
        let startPos = { x: 0, y: 0, set: false }; // Padrão centro se não definir

        const canvas = document.getElementById('fieldCanvas');
        const ctx = canvas.getContext('2d');
        const output = document.getElementById('outputCode');

        function init() {
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mousedown', onClick);
            canvas.addEventListener('contextmenu', e => e.preventDefault()); // Bloqueia menu
            document.addEventListener('keydown', e => { if(e.ctrlKey && e.key === 'z') undo(); });
            draw();
            updateCode();
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Grade
            let tileW = CANVAS_SIZE / GRID;
            ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '10px Arial';
            
            for (let r=0; r<GRID; r++) {
                for (let c=0; c<GRID; c++) {
                    let x = c*tileW; let y = r*tileW;
                    ctx.strokeRect(x, y, tileW, tileW);
                    // ID
                    let javaRow = (GRID-1)-r;
                    let id = (javaRow*GRID)+c+1;
                    ctx.fillStyle = '#555'; ctx.fillText(id, x+tileW/2, y+tileW/2);
                }
            }

            // Start Position (Azul)
            if (startPos.set) {
                let px = (startPos.x + FIELD_SIZE/2) * (CANVAS_SIZE/FIELD_SIZE);
                let py = (-startPos.y + FIELD_SIZE/2) * (CANVAS_SIZE/FIELD_SIZE); // Y Invertido
                
                ctx.fillStyle = '#00afff';
                ctx.beginPath(); ctx.arc(px, py, 8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = 'bold 12px Arial';
                ctx.fillText("START", px, py-12);
            }

            // Caminho (Verde)
            if (path.length > 0) {
                ctx.beginPath(); ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 3;
                
                // Desenha linha do Start até o primeiro ponto (opcional, mas ajuda a visualizar)
                if (startPos.set) {
                     let sx = (startPos.x + FIELD_SIZE/2) * (CANVAS_SIZE/FIELD_SIZE);
                     let sy = (-startPos.y + FIELD_SIZE/2) * (CANVAS_SIZE/FIELD_SIZE);
                     ctx.moveTo(sx, sy);
                }

                for (let i=0; i<path.length; i++) {
                    let center = getCanvasCenter(path[i]);
                    if (i===0 && !startPos.set) ctx.moveTo(center.x, center.y);
                    else ctx.lineTo(center.x, center.y);
                    
                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath(); ctx.arc(center.x, center.y, 4, 0, Math.PI*2); ctx.fill();
                }
                ctx.stroke();
            }
        }

        function getCanvasCenter(id) {
            let adj = id - 1;
            let r = Math.floor(adj / GRID);
            let c = adj % GRID;
            let cr = (GRID - 1) - r;
            let step = CANVAS_SIZE / GRID;
            return { x: c*step + step/2, y: cr*step + step/2 };
        }

        function getInfo(mx, my) {
            let realX = (mx / CANVAS_SIZE) * FIELD_SIZE - (FIELD_SIZE/2);
            let realY = -((my / CANVAS_SIZE) * FIELD_SIZE - (FIELD_SIZE/2)); // Y cresce pra cima no Java
            
            // ID calc
            let step = CANVAS_SIZE / GRID;
            let c = Math.floor(mx / step);
            let r = Math.floor(my / step);
            if(c>=GRID) c=GRID-1; if(r>=GRID) r=GRID-1;
            let javaRow = (GRID-1)-r;
            let id = (javaRow*GRID)+c+1;
            
            return { x: realX, y: realY, id: id };
        }

        function onClick(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const info = getInfo(e.clientX - rect.left, e.clientY - rect.top);

            if (e.button === 2) { // Clique Direito -> Start Pos
                startPos = { x: info.x, y: info.y, set: true };
            } else if (e.button === 0) { // Clique Esquerdo -> Caminho
                path.push(info.id);
            }
            draw();
            updateCode();
        }

        function undo() { path.pop(); draw(); updateCode(); }
        function clearPath() { path = []; startPos.set = false; draw(); updateCode(); }
        
        function onMove(e) {
            const rect = canvas.getBoundingClientRect();
            const info = getInfo(e.clientX - rect.left, e.clientY - rect.top);
            document.getElementById('mousePos').innerText = `X: ${info.x.toFixed(1)}, Y: ${info.y.toFixed(1)}`;
        }

        function updateCode() {
            let code = `// 1. Configuração Inicial\n`;
            code += `HarriGrid grid = new HarriGrid(144, 10);\n`;
            code += `HarriPath path = new HarriPath(grid);\n\n`;
            
            if (startPos.set) {
                code += `// IMPORTANTE: Diga à odometria onde o robô está!\n`;
                code += `odometry.setPosition(${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, 0);\n\n`;
            } else {
                code += `// ATENÇÃO: Clique com botão direito para definir o início!\n\n`;
            }

            code += `// 2. Construir rota\npath`;
            path.forEach(id => code += `.add(${id})`);
            code += `;\n`;

            output.value = code;
        }

        function copyCode() { output.select(); document.execCommand('copy'); }
        init();
    </script>
</body>
</html>